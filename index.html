<!doctype html>
<!-- 

CapJS ¬© Frank Force 2019

TODO
- text size setting
- allow dynamic imports for three.js
- embed options
- show capture aspect preview
- show FPS
- fix html share
- ccapture motion blur
- code to auto transform canvas 1920x1080 to 800x600
- better color picker
- mouse info object
- clean up pass
- abort save

-->
<html>
<meta charset="utf-8">
<head>
<title>CapJS ~ A live code editor for capturing video</title>
<link rel="shortcut icon" type="image/x-icon" href="favicon.png"/>


<script src="CCapture.all.min.js?1"></script> 
<!--
<script src="build/ccapture/CCapture.js"></script> 
<script src="build/ccapture/download.js"></script> 
<script src="build/ccapture/tar.js"></script> 
<script src="build/ccapture/webm-writer-0.2.0.js"></script> 
<script src="build/ccapture/gif.js"></script> 
<script src="build/ccapture/gif.worker.js"></script> 
-->

<script src="three.min.js"></script>


<!-- CodeMirror -->
<link rel=stylesheet href=codemirror/codemirror.css>
<script src=codemirror/codemirror.js></script>
<script src="codemirror/javascript.js"></script>
<script src="codemirror/clike.js"></script>
<script src="codemirror/xml.js"></script>
<script src="codemirror/addon/edit/matchbrackets.js"></script>
<script src="codemirror/addon/selection/active-line.js"></script>

<!-- CodeMirror Themes -->
<link rel="stylesheet" href="codemirror/theme/3024-night.css">
<link rel="stylesheet" href="codemirror/theme/abcdef.css">
<link rel="stylesheet" href="codemirror/theme/ambiance.css">
<link rel="stylesheet" href="codemirror/theme/blackboard.css">
<link rel="stylesheet" href="codemirror/theme/capjs.css?2">
<link rel="stylesheet" href="codemirror/theme/duotone-light.css">
<link rel="stylesheet" href="codemirror/theme/icecoder.css">
<link rel="stylesheet" href="codemirror/theme/lesser-dark.css">
<link rel="stylesheet" href="codemirror/theme/night.css">
<link rel="stylesheet" href="codemirror/theme/yonce.css">

<!-- CodeMirror Search -->
<link rel="stylesheet" href="codemirror/addon/dialog/dialog.css">
<script src="codemirror/addon/dialog/dialog.js"></script>
<script src="codemirror/addon/search/searchcursor.js"></script>
<script src="codemirror/addon/search/search.js"></script>
<script src="codemirror/addon/search/match-highlighter.js"></script>
<script src="codemirror/addon/scroll/annotatescrollbar.js"></script>
<link rel="stylesheet" href="codemirror/addon/search/matchesonscrollbar.css">
<script src="codemirror/addon/search/matchesonscrollbar.js"></script>
<script src="codemirror/addon/search/jump-to-line.js"></script>

<!-- CodeMirror Hints -->
<link rel="stylesheet" href="codemirror/addon/hint/show-hint.css">
<script src="codemirror/addon/hint/show-hint.js"></script>
<script src="codemirror/addon/hint/anyword-hint.js"></script>

<style>
.CodeMirror {
    border: 2px solid black;
    height:450px;
}
a {
    color:#5AF;
}
a:visited {
    color:#A5A;
}
body,input,select{
    font-family: "courier";
    color: #FFF;
}
button
{
    color: #000;
    font-size:20px;
    font-weight:bold;
}
button.small
{
    color: #000;
    font-size:15px;
    font-weight:bold;
}
textarea.watchWindow
{
    white-space:pre;
    overflow-wrap:normal;
    overflow-x:scroll; 
    background-color: #111;
    cursor: text;
    color: #FFF;
}
input
{
    background-color: #111;
}
select
{
    background-color: #111;
    width:100%;
}
.slider
{
    cursor: pointer;
    width:100%;
    height:25px;
}
.dragAndDrop
{
    color: #000;
    font-size:20px;
    font-weight:bold;
    height:50px;
    line-height: 50px;
    width:90%;
    background-color:#CCC;
    vertical-align: middle;
}
canvas
{
    width:640px;
    height:360px;
    border:1px solid black;
    background-color:#FFF
}
td
{
    vertical-align:top;
}
.nowrap
{
    white-space:nowrap;
}
</style>
<meta name="google" content="notranslate">
</head>
<body bgcolor="#222">
<tag autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
<table border=0>
<tr>
<td>

<center><font size=5><b>ùìíùì™ùìπùìôùì¢</b></font> A live code editor for capturing video</center>
</td>
<td>

<span class='nowrap'>
Mode
<select style="width:150px;" onchange="Reset()" id=modeSelect>
    <option>auto</option>
    <option>html</option>
    <option value=js>pure js</option>
    <option>dwitter + capjs</option>
    <option value=three>webgl + three.js</option>
    <option>shadertoy</option>
</select>
</span>

<span class='nowrap'>
On Change
<select style="width:100px;" id=onChangeSelect>
    <option>restart</option>
    <option>rebuild</option>
    <option value=nothing>do nothing</option>
</select>
</span>

<span class='nowrap'>
Theme
<select style="width:120px;" onchange="SelectTheme()" id=themeSelect>
    <option>3024-night</option>
    <option>abcdef</option>
    <option>ambiance</option>
    <option>blackboard</option>
    <option selected="selected">capjs</option>
    <option>default</option>
    <option>duotone-light</option>
    <option>icecoder</option>
    <option>lesser-dark</option>
    <option>night</option>
    <option>yonce</option>
</select>
<select style="width:40px;" onchange="SelectTheme()" id=fontSizeSelect>
    <option value=1.0>XS</option>
    <option value=1.5>S</option>
    <option value=2.0 selected="selected">M</option>
    <option value=2.5>L</option>
    <option value=3.0>XL</option>
</select>

</span>
</td>
</tr>

<tr><td rowspan=2 nowrap>
<iframe id=iframe_program style="width:655px;height:375px;"></iframe>
<canvas width=1920 height=1080 style="display:none" id=captureCanvas></canvas>
<br>
<table style="width:100%"><tr>
<td><button title="Go Fullscreen" style="width:50px;height:30px" id="fullscreenButton"onclick="ToggleFullscreen()">‚õ∂</button></td>
<td><button title="Screenshot (Alt+Right)" style="width:50px;height:30px" id="screenshotButton" onclick="SaveScreenshot()">üì∑</button></td>
<td><button title="Restart (Alt+Down)" style="width:50px;height:30px" id="restartButton" onclick="RestartButton()">‚ñê‚óÑ</button></td>
<td><button title="Pause/Resume (Alt+Up)" style="width:50px;height:30px" id="pauseButton" onclick="TogglePause()">‚ñå‚ñå</button></td>
<td><table width=90 border=1><tr><td><center><span id="timeDisplay">0</span></center></td></tr></table></td>
<td style="width:100%"><input type="range" min="1" max="1800" value="1" class="slider" id="timeRangeSlider" onmousedown="isSliding=1" onmouseup="isSliding=0" oninput="TimeSliderInput()"></td>
</tr></table>
<center>
<font size=5>Program Name </font><input id=filenameInput value='Default' style="width:300px;height:30px;font-size:25px;">
<br><br><button id="captureButton" onclick="ToggleCapture()" style="width:170px;height:45px;background-color:#8F8;" title="Render and save animation">Capture</button>
<button id="shareButton" onclick="Share()" style="height:45px;background-color:#FF8;"title="Create link to code that can be shared or bookmarked">Share</button>
<button id="saveButton" onclick="Save()" style="height:45px;background-color:#8FF;" title="Save code as a text file" >Save</button>
<button id="loadButton" onclick="fileInput.click()" style="height:45px;background-color:#F88;" title="Load code from a text file, you can also drag and drop files into the editor">Load</button>
<button id="resetButton" onclick="ResetButton()" style="height:45px;background-color:#000;color:#F00" title="Reset everything to the default state">Reset</button>
<br>
<input id="fileInput" type="file" style="display:none">

<br>Resolution
<input type="number" id=CaptureWidth value=960 min=1 max=7680 style="width:60px">
x <input type="number" id=CaptureHeight value=540 min=1 max=4320 style="width:60px">
Format
<select style="width:100px;" id=formatSelect>
    <option>gif</option>
    <option>webm</option>
    <option>png</option>
    <option>jpg</option>
</select>
<br>
<br>
Capture Time (s)
<input type="number" id=CaptureTimeInput value=2 style="width:60px">
Framerate
<input type="radio" name="framerateSelector" value="30">30
<input type="radio" name="framerateSelector" value="60" checked>60
<br>
<br>
Speed
<input type="number" id=TimeScale value=1 min=0 max=100 style="width:60px">
Aspect
<select style="width:80px;" id=aspectSelect>
    <option>stretch</option>
    <option>center</option>
    <option>fill</option>
    <option>fit</option>
</select>
Advanced
<input type="checkbox" id=showAdvancedSettings>
<div id="advancedSettings" style="display:none;">
<br>
<hr width=80%>
<button class="small" onclick=SetResolution(400,300)  >400:300</button>
<button class="small" onclick=SetResolution(800,600)  >800:600</button>
<button class="small" onclick=SetResolution(480,270)  >480:270</button>
<button class="small" onclick=SetResolution(960,540)  >960:540</button>
<button class="small" onclick=SetResolution(1920,1080)>1920:1080</button>
<br><br>
Preserve Aspect Ratio
<input type="checkbox" id="preserveAspectRatio" checked>
Centering Overlay
<input type="checkbox" id="centeringOverlay">
<br><br>
Custom Image <input id=imageFileInput type="file" accept="image/*">
<br><br>
Background <input type="color" id=BackgroundColor value="#ffffff">
Canvas Size
<input type="number" id=CanvasWidth value=1920 min=1 style="width:60px">
x <input type="number" id=CanvasHeight value=1080 min=1 style="width:60px">
</div>
</center>
</td>
<td style="width:100%; vertical-align:top;">

<textarea hidden id=codeTextArea></textarea>

Code Size: <span id="codeLengthLines">0</span> lines, <span id="codeLengthChars">0</span> characters, <span id="codeLength">0</span> bytes
<br>
<br><textarea id='errorText' rows=3 readonly style="width:100%;background-color: #000; color:#F00;" ></textarea>
<br>
<div id=consoleTextDiv style='display:none'>
Console Output
<br><textarea id='consoleText' rows=3 readonly style="width:100%;background-color: #000;visibility:none; color:#FF0;" ></textarea>
</div>
<button class="small" onclick=Beautify() title="Clean up and uncompress code">Beautify</button>
<button class="small" onclick=Unbeautify() title="Remove most excess whitespace from code">Minify</button>
<button class="small" onclick=DwitterCompress() title="Apply unicode compression (2:1 character encoding)">Compress</button>
<button class="small" onclick=JSCrushCompress() title="Apply JSCrush compression (removes repeated strings)">JSCrush</button>

<span class='nowrap'>
Show Help <input type="checkbox" id="showHelp" title="Display help and example code">
</span>
<span class='nowrap'>
Watch Window <input type="checkbox" id="showWatchWindow" title="Display object debug info">
</span>
<span class='nowrap'>
Loop Protect <input type="checkbox"id="loopProtectOption" onChange=SetCode() checked title="Try to prevent infinte loops">
</span>
<span id=watchWindow style="display:none">
<br><br>
Watch Objects <input id=infoInput style="width:300px" placeholder="Type object names here" onkeyUp=UpdateWatchWindow(infoInput.value) onchange=UpdateWatchWindow(infoInput.value)>
<br><textarea class="watchWindow" style="width:100%;" cols=100 rows=10 id=watchWindowTextArea readonly></textarea>
</span>
</td>
</tr><tr>

<td style="vertical-align: top;">
<span id=helpDisplay>
<table border=0><tr>
<td width=10></td>
<td style="vertical-align: top;">
<pre>
<b>CapJS shortcuts...</b>

Alt+Up: Toggle Play/Pause
Alt+Down: Restart/Rebuild
Ctrl+F: Search
Ctrl+G: Find Next
Shift+Ctrl+F: Replace
Alt+G: Jump to Line
Ctrl+Space: Autocomplete
Drag+Drop: Load program in text box

<b>Global functions and variables...</b>

u(t) is called 60 times per second
t: Elapsed time in seconds
S: Shorthand for Math.sin
C: Shorthand for Math.cos
T: Shorthand for Math.tan
R: Function that generates rgba-strings
c: 1920x1080 canvas
x: 2D or webgl context for that canvas
PI: Math.PI
renderer: three.js renderer if enabled
image: custom image if loaded
DrawImage: Helper function to draw images

</pre>
</td>
<td width=20></td>
<td style="vertical-align: top;">

<pre>
<b>// three.js example</b>

if (!t)
{
scene = new THREE.Scene()
camera = new THREE.PerspectiveCamera(75,16/9)
scene.add(new THREE.AmbientLight(0x222222))
scene.add(new THREE.DirectionalLight())
geometry = new THREE.BoxGeometry(1,1,1)
material = new THREE.MeshLambertMaterial()
cube = new THREE.Mesh(geometry,material)
cube.position.set(0,0,-2)
scene.add(cube)
}
cube.rotation.set(0,t,t*2)
renderer.render(scene,camera)


// shadertoy example

void mainImage(out vec4 c, in vec2 p)
{
vec2 uv = p/iResolution.xy;
c = vec4(.5+.5*cos(iTime+uv.xyx+vec3(0,2,4)),1);
c += iMouse/iResolution.xyxy; // mouse input
//c = texture(iChannel0,uv); // custom image
}

</pre>
</td>
</tr></table>
</span>
</td>
</tr></table>
<hr>
<center>
CapJS ¬© <a href="http://www.frankforce.com" target="_blank">Frank Force</a> 2019 ~ Using <a href="https://github.com/spite/ccapture.js/" target="_blank">CCapture.js</a>, <a href="https://threejs.org/" target="_blank">three.js</a>, <a href="https://github.com/xem/miniBeautifier"target="_blank">MiniBeautifier</a>, and <a href="https://codemirror.net/" target="_blank">CodeMirror</a> ~ Inspired By <a href="https://www.dwitter.net/" target="_blank">Dwitter</a> ~ ‚òÆ‚ô•‚òª‚êå
</center>
<script>

function CustomInit()
{
}

function CustomUpdate(t, c, x)
{

}

CodeMirror.commands.autocomplete = function(cm) {
    cm.showHint({hint: CodeMirror.hint.anyword});
}

// setup code mirror
let codeMirrorEditor = CodeMirror.fromTextArea(document.getElementById('codeTextArea'), {
mode: 'javascript',
lineNumbers: true,
lineWrapping: true,
autofocus:true,
styleActiveLine: true,
matchBrackets: true,
smartIndent: false,
extraKeys: {"Alt-F": "findPersistent", "Ctrl-Space": "autocomplete"}
});

codeMirrorEditor.addKeyMap({"Alt-Up":   _=>TogglePause()});
codeMirrorEditor.addKeyMap({"Alt-Down": _=>RestartButton()});
codeMirrorEditor.addKeyMap({"Alt-Right":_=>SaveScreenshot()});
codeMirrorEditor.addKeyMap({"Alt-Enter":_=>RestartButton()});
//codeMirrorEditor.addKeyMap({"Alt-F":    _=>ToggleFullscreen()});
//codeMirrorEditor.addKeyMap({"Alt-C":    _=>ToggleCapture()});
//codeMirrorEditor.addKeyMap({"Alt-S":    _=>Save()});
//codeMirrorEditor.addKeyMap({"Alt-Space":_=>RestartButton()});

function SelectTheme()
{
    codeMirrorEditor.setOption("theme", themeSelect.value);
    codeMirrorEditor.getWrapperElement().style.fontSize = fontSizeSelect.value + 'em';
    
}
  
// fix problem with instanceof error not working across iframes
let IsError=e=>(e && e.stack && e.message && typeof e.stack === 'string' && typeof e.message === 'string');

let defaultProgram="c.width|=0\nfor(i=1e3;i--;)\nx.fillRect(960+900*S(i*2),540+500*C(t*PI/2+i*3),29,29)"
let time=0;
let frame=1;
let paused=0;
let wasPaused=0;
let capturer=0;
let captureTime=0;
let captureTimeLimit=0;
let captureFramerate=0;
let processingPercent=0;
let manuallyPaused=1;
let codeIsSafe=0;
let image=0;
let captureWidth,captureHeight;
let mode=0;
let modeHasCanvas=1;
let mouseX=0;
let mouseY=0;
let mouseZ=0;
let mouseW=0;
let mainCanvas=0;
let mainCanvasContext=0;
let iframe_content=0;
let iframeGlobals={};
let isSliding = 0;

let shaderErrorText = 0;
let shaderProgram = 0;
let shaderTexture = 0;

function Reset()
{
    time=0;
    paused=0;
    frame=1;
    
    consoleTextDiv.style.display = 'none';
    
    mode=modeSelect.value;
    if (mode == "auto")
    {
        if (codeMirrorEditor.getValue().indexOf('THREE') >= 0)
            mode = "three"
        else if (codeMirrorEditor.getValue().search(/void\s+mainImage/g) >= 0)
            mode = "shadertoy"
        else if (codeMirrorEditor.getValue().indexOf('<html>') == 0)
            mode = "html"
    }
    
    modeHasCanvas = (mode != "html" && mode != "js")
    
    let modeOption = "javascript";
    if (mode=="html")
        modeOption = "xml"
    else if (mode=="shadertoy")
        modeOption = "text/x-c++src"
    codeMirrorEditor.setOption("mode", modeOption);
    
    InitFrame();
    
    if (mode == "html" || mode == "js")
    {
        // no init
    }
    else if (mode == "shadertoy")
    {
        mainCanvasContext = mainCanvas.getContext('webgl2');
        iframe_content.x = mainCanvasContext;
    }
    else if (mode == "three")
    {
        // init ThreeJS
        renderer = new THREE.WebGLRenderer({canvas: mainCanvas});
        iframe_content.THREE=THREE;
        iframe_content.renderer = renderer;
        mainCanvasContext = iframe_content.renderer.context;
        iframe_content.x = mainCanvasContext;
    }
    else
    {
        mainCanvasContext = mainCanvas.getContext('2d');
        iframe_content.x = mainCanvasContext;
    }
    
    SetCode();
    
    // do one update right away
    UpdateFrame(1);
}

function ToggleFullscreen()
{
    if (iframe_program.webkitRequestFullScreen)
        iframe_program.webkitRequestFullScreen();
    else
        iframe_program.mozRequestFullScreen();
}
 
function TimeSliderInput()
{
    time=timeRangeSlider.value/60
    frame=timeRangeSlider.value
    if (time==0)
        Reset();
        
    //paused=1
    UpdateFrame(1, 1);
}

function RestartButton()
{
    if (!codeIsSafe)
        manuallyPaused=0;
    codeIsSafe=1;
    Reset();
}

function TogglePause()
{
    codeIsSafe=1;
    manuallyPaused=!manuallyPaused;
    paused=manuallyPaused;
    //SetErrorText("");
}

let wasDropped = 0;
codeMirrorEditor.on("drop",function(editor,e) { 
{
    if (e.dataTransfer.files.length > 0)
    {
        codeMirrorEditor.setValue("");
        filenameInput.value = e.dataTransfer.files[0].name.replace(/\.[^/.]+$/, "")
        wasDropped = 1;
        codeIsSafe=1;
        manuallyPaused = 0;
    }
}});

codeMirrorEditor.on("change", 
function(codeMirror, changeObject)
{
    let onChangeMode = onChangeSelect.value;
    if (changeObject.origin != "setValue")
    {
        //if (!codeIsSafe && onChangeMode != "nothing")
        //    manuallyPaused=0;
        //codeIsSafe = 1; // mark as safe on input
    }

    if (changeObject.origin=="paste" 
      && changeObject.from.line==0 && changeObject.from.ch==0 )
    {
        DwitterUncompress();
    }
    if (onChangeMode == "restart" || wasDropped)
    {
        wasDropped = 0;
        Reset();
    }
    else if (onChangeMode == "rebuild")
    {
        // update just 1 frame
        SetCode();
        UpdateFrame(1, 1);
    }
});

function JSCrushCompress()
{
    if (mode == "html")
        return;

    let code = codeMirrorEditor.getValue();
    
    // minify first
    //code = BeautifyJS(code, true);
    
    code = JSCrush(code);
    codeMirrorEditor.setValue(code);
}

function DwitterCompress()
{
    if (mode == "html")
        return;
    
    // replace unicode characters
    const codeIn = [...codeMirrorEditor.getValue().trim()];
    let code = '';
    for( let character of codeIn)
    {
        const charCode = character.charCodeAt(0);
        if (charCode > 255)
            character = escape(character).replace(/%u/g,'\\u');
        code += character;
    }
    
    // 2-1 character compression
    let dwitterCompressed = String.fromCharCode(...[...code.length%2?code+';':code].map((e,i)=>e.charCodeAt()|(i%2?55:54)<<10))
    dwitterCompressed = "eval(unescape(escape`"+ dwitterCompressed +"`.replace(/u../g,'')))";
    codeMirrorEditor.setValue(dwitterCompressed);
}

function DwitterUncompress()
{
    if (mode == "html")
        return;
    
    let code = codeMirrorEditor.getValue();
    code = Uncompress(code);
    codeMirrorEditor.setValue(code);
}

function Beautify()
{
    if (mode == "html")
        return;
    
    let code = codeMirrorEditor.getValue();
    code = BeautifyJS(code);
    codeMirrorEditor.setValue(code);
}

function Unbeautify()
{
    if (mode == "html")
        return;
    
    let code = codeMirrorEditor.getValue();
    code = BeautifyJS(code, true);
    codeMirrorEditor.setValue(code);
}

function InitFrame()
{  
    // re-create iframe and canvas
    let iframe_programNew = document.createElement('iframe')
    iframe_program.before(iframe_programNew);
    iframe_program.remove();
    iframe_program = iframe_programNew;
    iframe_content = iframe_program.contentWindow || iframe_program.contentDocument;
    
    let html = '<style>*{padding:0;margin:0;border:0;outline:0;overflow:hidden;}canvas{background:#FFF;width:100%}</style><body style="overflow:hidden">\
    <div id="centering_V" style="display:none; position:absolute; border-left:4px solid #F00A; position:absolute; height:100%; left:50%; margin-left:-2px;"></div>\
    <div id="centering_H"  style="display:none; position:absolute; border-top:4px solid #F00A; position:absolute; width:100%; top:50%; margin-top:-2px;"></div>';
    
    if (modeHasCanvas)
        html += '<canvas width=1920 height=1080 id=c></canvas></body>';
    
    if (mode == "html")
        html = codeMirrorEditor.getValue();
    
    iframe_content.document.open();
    iframe_content.document.write(html);
    iframe_content.document.close();

    iframe_program.sandbox.add('allow-scripts');
    iframe_program.sandbox.add('allow-same-origin');
    iframe_program.style.width="655px"
    iframe_program.style.height="375px"

    mainCanvasContext=0;
    mainCanvas=0;
    mouseX = mouseY = mouseZ = mouseW = 0;
    
    // init globals
    if (modeHasCanvas)
    {
        mainCanvas = iframe_content.c;
        mainCanvas.width=parseInt(CanvasWidth.value);
        mainCanvas.height=parseInt(CanvasHeight.value);
        
        // shadertoy mouse input
        mainCanvas.onmousemove=e=>
        { 
            if (e.buttons)
            {
                const rect = mainCanvas.getBoundingClientRect();
                scaleX = mainCanvas.width / rect.width,
                scaleY = mainCanvas.height / rect.height;
                mouseX = (e.clientX- rect.left) * scaleX; 
                mouseY = (rect.height - e.clientY- rect.top) * scaleY; 
            }
        }
        mainCanvas.onmousedown=e=>
        { 
            const rect = mainCanvas.getBoundingClientRect();
            scaleX = mainCanvas.width / rect.width,
            scaleY = mainCanvas.height / rect.height;
            mouseZ = (e.clientX- rect.left) * scaleX; 
            mouseW = (rect.height - e.clientY- rect.top) * scaleY; 
        }
        mainCanvas.onmouseup=e=>{mouseZ = mouseW = 0}; 
    
        const dwitterFunctions=
        `
            PI=Math.PI;
            S=a=>Math.sin(a);
            C=a=>Math.cos(a);
            T=a=>Math.tan(a);
            R=(r,g,b,a)=>(a =(a === undefined ? 1 : a),"rgba("+(r|0)+","+(g|0)+","+(b|0)+","+a+")");
            DrawImage=(theImage,X,Y,SX,SY,A)=>
            {
                x.save();
                x.translate(X, Y);
                x.rotate(A);
                x.drawImage(theImage, -SX/2, -SY/2, SX, SY);
                x.restore();
            }
            _CONSOLE_LOG = '';
            console.log=(...s)=>_CONSOLE_LOG += s.join(' ');
        `

        eval(dwitterFunctions);
        iframe_content.eval(dwitterFunctions);
        iframe_content.eval(DrawImage+"");
    }
    
    FitToWidow();
}

function SetCode()
{
    if (!iframe_content)
        return;

    paused = 0;
    code=codeMirrorEditor.getValue();
    iframe_content.code = code;
    localStorage.code = code;
    
    SetErrorText("");
    ResetShader();
    
    if (mode == "shadertoy")
    {
        SetShader(code);
        if (shaderErrorText)
        {
            SetErrorText(shaderErrorText);
            if (shaderErrorText)
                paused=1;
        }
    }
    else if (mode == "js")
    {
        try
        {
            iframe_content.eval(code)
        }
        catch (e) 
        {   
            paused = 1;
            iframe_content.UserUpdateFunction=function u(t) {}
            if (IsError(e))
                errorValue = e.message? "Error: " + e.message : e;
            else
                errorValue = e;
            SetErrorText(errorValue);
        }
    }
    else if (modeHasCanvas)
    {
        WrapCodeWithLoopProtect=code=>
        {
            if (!loopProtectOption.checked)
                return code;
                
            // insert loop buster into for and while loop statements
            return code.replace
            (
                /(for\s*\((?!\s+of\s+)(?!\s+in\s+)[^;]*;[^;]*;|while\s*\()\s*(\S)/g, 
                (loopBody, group1, group2)=>
                    group1 && group2? group1 +
                    `Date.now()>maxLoopTime&&function(){throw new Error('Frame timed out!')}()` +
                    (group2 == ')' ? '' : ',') + group2 : loopBody
            );
        }
        let codeFunction="function u(t){\n"+WrapCodeWithLoopProtect(code)+"\n}"

        try
        {
            iframe_content.eval(codeFunction);
            iframe_content.window.u = iframe_content.u;
            iframe_program.u = iframe_content.u;
        }
        catch (e) 
        {
            paused = 1;
            iframe_content.UserUpdateFunction=function u(t) {}
            if (IsError(e))
                errorValue = e.message? "Error: " + e.message : e;
            else
                errorValue = e;
            SetErrorText(errorValue);
        }
    }
    
    // save all variables the program started with
    iframeGlobals = {};
    Object.keys(iframe_content).forEach(key =>{iframeGlobals[key]=iframe_content[key];});
}

function Share()
{
    prompt("CapJS Code URL\nThis url contains your entire program!\nYou can share or bookmark this link.", SaveToURL());
}

function Save()
{
    let filename = filenameInput.value
    if (filename=="")
        filename="CapJSProgram"
    if (filename.indexOf(".")<0)
        filename += ".txt";
    
    download(codeMirrorEditor.getValue(), filename, "data:application/octet-stream");
}

function SetResolution(width, height)
{
    CaptureWidth.value=width;
    CaptureHeight.value=height;
}

function LoadFile(file)
{
    if (file.type != "text/plain")
        return;

    let reader = new FileReader();
    reader.readAsText(file,'UTF-8');
    reader.onload=readerEvent=>
    {
        let content = readerEvent.target.result;
        codeMirrorEditor.setValue(content);
        filenameInput.value = file.name.replace(/\.[^/.]+$/, "")
        Reset();
    }
}

function LoadImage(file)
{
    if (!file)
        return 0;
    
    let reader = new FileReader();
    let newimage = new Image();
    reader.readAsDataURL(file);
    reader.onload=readerEvent=>
    {
        let content = readerEvent.target.result;
        newimage.src = content;
    }
    return newimage
}

// Load code
fileInput.onchange=e=>
{
   LoadFile(e.target.files[0]);
}

// Load image
imageFileInput.onchange=e=>
{
   image = LoadImage(e.target.files[0]);
}

function SaveToURL()
{
    let search = "";
    search += "filename=" + encodeURIComponent(filenameInput.value);
    if (mode != "auto")
        search += "&mode=" + encodeURIComponent(mode);
        
    let code = codeMirrorEditor.getValue();
    search += "&crushed=" + JSONCrush(code);
    
    let url = new URL(window.location.href);
    url.search = search;
    return url.toString();
}

function LoadFromURL(href)
{
    let url = new URL(href);
    let searchParams = url.searchParams;
    if (searchParams.has('code') || searchParams.has('crushed'))
    {
        codeIsSafe = 1;
        manuallyPaused = 0;
        if (searchParams.has('filename'))
            filenameInput.value = searchParams.get('filename')
        if (searchParams.has('code'))
            codeMirrorEditor.setValue(searchParams.get('code'));
        if (searchParams.has('crushed'))
            codeMirrorEditor.setValue(JSONUncrush(searchParams.get('crushed')));
        if (searchParams.has('mode') && modeSelect.selectedIndex>=0)
            modeSelect.value = searchParams.get('mode');
        else
            modeSelect.value = "auto";
        
        return true;
    }
    
    return false;
}

function SaveScreenshot()
{    
    if (!capturer)
    {
        // update the capture canvas if we aren't aready capturing video
        captureWidth = CaptureWidth.value;
        captureHeight = CaptureHeight.value;
        UpdateShader();
        
        UpdateCaptureCanvas();
    }
    
    let format = formatSelect.value;
    if (format != 'png' && format != 'jpg')
        format = 'png';
    
    download2(captureCanvas.toDataURL("image/"+format), filenameInput.value+"."+format,"image/"+format);
}

function ResetButton()
{
    if (!confirm('Are you sure you want to reset and clear everything?'))
        return;

    let settings = 
    {
        filename:            'Default',
        format:              'gif',
        frameRate:           "60",
        captureTime:         2,
        captureWidth:        960,
        captureHeight:       540,
        aspect:              'fill',
        timeScale:           1,
        centeringOverlay:    0,
        onChange:            'restart',
        preserveAspectRatio: 1,
        backgroundColor:     '#FFFFFF',
        showWatchWindow:     0,
        mode:                'auto',
        loopProtectOption:   'true',
        showAdvancedSettings:showAdvancedSettings.checked,
        theme:               themeSelect.value,
        canvasWidth:         1920,
        canvasHeight:        1080,
    };

    localStorage.settings = JSON.stringify(settings);
    localStorage.code = defaultProgram;
    LoadLocalStorage();
    SetCode();
    
    manuallyPaused=0;
    paused=0;
    codeIsSafe=1;
    SetErrorText("");
    
    Reset();
}

function SaveLocalStorage()
{
    if (!document.hasFocus())
        return;

	let captureFramerate = parseInt(document.querySelector('input[name="framerateSelector"]:checked').value);
    let settings = 
    {
        filename:            filenameInput.value,
        format:              formatSelect.value,
        frameRate:           captureFramerate,
        captureTime:         CaptureTimeInput.value,
        captureWidth:        CaptureWidth.value,
        captureHeight:       CaptureHeight.value,
        aspect:              aspectSelect.value,
        timeScale:           TimeScale.value,
        centeringOverlay:    centeringOverlay.checked,
        onChange:            onChangeSelect.value,
        preserveAspectRatio: preserveAspectRatio.checked,
        backgroundColor:     BackgroundColor.value,
        mode:                modeSelect.value,
        code:                defaultProgram,
        showAdvancedSettings:showAdvancedSettings.checked,
        theme:               themeSelect.value,
        fontSize:            fontSizeSelect.value,
        canvasWidth:         parseInt(CanvasWidth.value),
        canvasHeight:        parseInt(CanvasHeight.value),
    };

    localStorage.settings = JSON.stringify(settings);
}

function LoadLocalStorage()
{
    // load saved code or default program
    let code=localStorage.code;
    if (code && typeof code == 'string' && code != "")
    {
        codeMirrorEditor.setValue(localStorage.code);
        if (!codeIsSafe)
            SetErrorText("Saved program loaded! Modify code or unpause to execute.");
    }
    else
    {
        codeMirrorEditor.setValue(defaultProgram);
        codeIsSafe=1;
        manuallyPaused=0;
    }
    
    if (!localStorage.settings)
    {
        SelectTheme();
        return;
    }
        
    let settings = JSON.parse(localStorage.settings);
    
    CaptureTimeInput.value       = settings.captureTime;
    CaptureWidth.value           = settings.captureWidth;
    CaptureHeight.value          = settings.captureHeight;
    TimeScale.value              = settings.timeScale;
    showAdvancedSettings.checked = settings.showAdvancedSettings;
    centeringOverlay.checked     = settings.centeringOverlay;
    preserveAspectRatio.checked  = settings.preserveAspectRatio;
    BackgroundColor.value        = settings.backgroundColor;
    CanvasWidth.value            = settings.canvasWidth;
    CanvasHeight.value           = settings.canvasHeight;
    filenameInput.value          = settings.filename;
        
    modeSelect.value = settings.mode;
    if (modeSelect.selectedIndex<0)    
        modeSelect.value = "auto"
        
    formatSelect.value = settings.format;
    if (formatSelect.selectedIndex<0)    
        formatSelect.value = "gif"
        
    onChangeSelect.value = settings.onChange;
    if (onChangeSelect.selectedIndex<0)    
        onChangeSelect.value = "restart"
        
    aspectSelect.value = settings.aspect;
    if (aspectSelect.selectedIndex<0)    
        aspectSelect.value = "stretch"
        
    themeSelect.value = settings.theme;
    if (themeSelect.selectedIndex<0)    
        themeSelect.value = "capjs"
    
    fontSizeSelect.value = settings.fontSize;
    if (fontSizeSelect.selectedIndex<0)    
        fontSizeSelect.value = "2.0"
        
    SelectTheme();
    
    let radioBox = document.getElementsByName('framerateSelector');
    for (let i = 0; i < radioBox.length; i++)
        radioBox[i].checked = (radioBox[i].value == settings.frameRate);
}

function CountCharacters(string) { return [...string].length; }

function RefreshUI()
{
    if (!isSliding)
        timeRangeSlider.value=time*60
    if (frame<=2)
        timeDisplay.innerHTML="0.00"
    else
        timeDisplay.innerHTML = (time-1/60).toFixed(2);
        
    if (document.activeElement != timeRangeSlider)
        pauseButton.innerHTML = paused||manuallyPaused? "‚ñ∫" : "‚ñå‚ñå"
    
    let s=""
    if (captureButton.disabled)
        s=`Processing ${processingPercent*100|0}%`;
    else if (capturer)
    {
        if (captureTimeLimit>0)
        {
            let p = Math.floor(100*captureTime/captureTimeLimit);
            s=`Stop ${p}%`
        }
        else
            s="Stop"
    }
    else
        s="Capture"
    captureButton.innerHTML=s;
    captureButton.style.background=captureButton.disabled?"#88F":capturer?"#F88":"#8F8";
    advancedSettings.style.display = showAdvancedSettings.checked? "inline" : "none";
    
    codeLength.innerHTML=(new TextEncoder('utf-8').encode(codeMirrorEditor.getValue())).length;
    codeLengthChars.innerHTML=CountCharacters(codeMirrorEditor.getValue());
    codeLengthLines.innerHTML=codeMirrorEditor.lineCount();
    
    watchWindow.style.display = showWatchWindow.checked? "inline" : "none";
    helpDisplay.style.display = showHelp.checked? "inline" : "none";
    
    if (modeHasCanvas)
    {
        let showCenter = centeringOverlay.checked;
        iframe_content.centering_V.style.display = showCenter? "inline" : "none";
        iframe_content.centering_H.style.display = showCenter? "inline" : "none";
    }
}

function UpdateWatchWindow(objectNames)
{
    if (paused)
        return;
    
    let output = '';
    if (objectNames.trim()=='')
    {
        watchWindowTextArea.value = '';
        
        // show all new variables
        for(key of Object.keys(iframe_content))
        {
            if (typeof iframeGlobals[key] !== 'undefined')
            {
                if (iframeGlobals[key] == iframe_content[key])
                    continue;
            }
            
            // prevent internal variables from showing by default
            if (['x','code','innerWidth','screenshot','innerHeight','maxLoopTime','image','time','t','frame','_CONSOLE_LOG'].indexOf(key) >= 0)
                continue;
            
            objectNames += key + ' '
        }
    }
    
    if (objectNames.trim()=='')
    {
        watchWindowTextArea.value = '';
        return;
    }
    
    objectNames=objectNames.replace(/ /g,',');
    let objectNameList = objectNames.split(',')
    for( objectName of objectNameList )
    {
        objectName = objectName.trim();
        if (objectName=='')
            break;
    
        try
        {
            output += objectName +' = ';
            let theObject = iframe_content.eval(objectName);
            if (typeof theObject == 'function')
                output += theObject.toString().replace(/(\n|\r)/g,'\\n');
            else
                output += JSON.stringify(theObject);
        }
        catch (e) 
        {
            output += 'undefined';
        }
        output += '\n';
    }
    
    watchWindowTextArea.value = output;
}

function CaptureProgress(p)
{
    processingPercent=p;
    captureButton.disabled = p<1
}

function ToggleCapture()
{
    codeIsSafe=1;
    
    if (capturer)
    {
        capturer.stop();
        capturer.save();
        capturer=0;
        return;
    }
    
    if (!modeHasCanvas)
    {
        alert("Can't capture in a non canvas mode!");
        return;
    }
    
    manuallyPaused=0;
    let onChangeMode = onChangeSelect.value;
    if (onChangeMode == "restart")
        Reset();
    
    paused=0;
	captureFramerate = parseInt(document.querySelector('input[name="framerateSelector"]:checked').value);
    let format = formatSelect.value;
    captureTimeLimit = parseFloat(CaptureTimeInput.value)
    if (captureTimeLimit<0)
        captureTimeLimit=0
    capturer = new CCapture({ 
        //display: true,
        framerate: captureFramerate,
        format: format,
        timeLimit: captureTimeLimit,
        workersPath: './',
        name: filenameInput.value,
		onProgress: function( p ) { CaptureProgress(p); }
    });
    capturer.start();
    
    captureWidth=parseInt(CaptureWidth.value);
    captureHeight=parseInt(CaptureHeight.value);
    captureWidth=(captureWidth>0&&captureWidth<=1920*4)?captureWidth:1920*4;
    captureHeight=(captureHeight>0&&captureHeight<=1080*4)?captureHeight:1080*4;
    captureTime=0;
}

function SetErrorText(text)
{
    errorText.value = text;
}

function SetConsoleText(text)
{
    if (text)
        consoleTextDiv.style.display='inline';
    consoleText.value = text;
}

let updateTimeBuffer=0

function UpdateFrame(forceUpdate, preventTimeChange)
{
    // set background color
    if (mainCanvas)
        mainCanvas.style.background = BackgroundColor.value;
    if (iframe_program)
        iframe_program.style.background=BackgroundColor.value
    if (iframe_content.renderer)
        iframe_content.renderer.setClearColor(BackgroundColor.value);
        
    
    RefreshUI();
    
    if (!codeIsSafe)
        return;
        
    if(!paused && !isSliding && !manuallyPaused || forceUpdate)
    {
        updateCount = 1;
        
        let timeScale = parseFloat(TimeScale.value);
        if (timeScale < 0)
            timeScale=0;
        else if (timeScale > 100)
            timeScale=100;
        else if (!(timeScale >= 0 && timeScale <= 100))
            timeScale=0;
        if (capturer && captureFramerate==30)
            timeScale *= 2;
        
        updateTimeBuffer += timeScale
        updateCount = (updateTimeBuffer|0);
        updateTimeBuffer -= updateCount;
            
        for(;updateCount--;)
        {
            let errorValue = "";
            try
            {
                let canvasWidth = parseInt(CanvasWidth.value);
                let canvasHeight = parseInt(CanvasHeight.value);
                if (preserveAspectRatio.checked && mainCanvas.width!=canvasWidth && mainCanvas.height==canvasHeight)
                {
                    // auto preserve aspect ratio if width is changed and height isnt
                    let height = Math.round(mainCanvas.width * canvasHeight / canvasWidth);
                    height = height & ~1 // keep it even
                    if (mainCanvas.height != height)
                        mainCanvas.height = height;
                }
                
                let programTime = time;
                if (programTime > 0 && (programTime * 60 | 0 == frame - 1))
                    programTime += 0.000001; // fix time not matching frame due to floating point error

                if (modeHasCanvas)
                {
                    iframe_content._CONSOLE_LOG = '';
                    iframe_content.t=time;
                    iframe_content.image=image;
                    iframe_content.screenshot=SaveScreenshot;
                    iframe_content.time=time;
                    iframe_content.frame=frame;
                    iframe_content.window.u = iframe_program.u;
                    const isCapturing = capturer && !captureButton.disabled;
                    iframe_content.maxLoopTime = Date.now() + (isCapturing?5e4:250);
                    if (typeof iframe_content.window.u == "function")
                        iframe_content.window.u(programTime);

                    UpdateShader();
                }

                CustomUpdate(programTime, mainCanvas, mainCanvasContext);
            }
            catch (e) 
            {
                if (typeof e === "undefined")
                    errorValue = "undefined";
                else if (IsError(e))
                    errorValue = e.message? "Error: " + e.message : e;
                else
                    errorValue = e;
                SetErrorText(errorValue);
            }
            
            if (modeHasCanvas)
                SetConsoleText(iframe_content._CONSOLE_LOG);

            if (!preventTimeChange || time==0)
            {
                time+=1/60;
                ++frame;
            }
        }
        captureTime+=(captureFramerate==30?2:1)/60
    }

    if (capturer)
    {
        UpdateCaptureCanvas();
        capturer.capture( captureCanvas );
        
        if (captureTimeLimit && captureTime > captureTimeLimit)
            capturer = 0;
    }
    
    UpdateWatchWindow(infoInput.value);
}

function FitToWidow()
{
    let width = window.innerWidth - 50;
    
    let maxFrameWidth = 700;
    let frameWidth = maxFrameWidth;
    let inputWidth = width - frameWidth;
     
    if (inputWidth < 600)
    {
        frameWidth += inputWidth - 600;
        if (frameWidth < 500)
            frameWidth = 500;

        inputWidth += maxFrameWidth - frameWidth;
    }
    if (inputWidth < 300)
        inputWidth = 300;
    
    iframe_program.style.width=frameWidth+'px';
    iframe_program.style.height=frameWidth*9/16+'px';
    
    codeMirrorEditor.setSize(inputWidth, null);
    errorText.style.maxWidth= inputWidth+'px';
    watchWindowTextArea.style.maxWidth= inputWidth+'px';
}

function UpdateFrameLoop()
{
    FitToWidow();

    if (capturer)
        requestAnimationFrame( UpdateFrameLoop );
    else
	   setTimeout( UpdateFrameLoop, 16 );
    UpdateFrame();
    SaveLocalStorage();
} 

function UpdateCaptureCanvas()
{
    let captureCanvasContext = captureCanvas.getContext('2d');
    captureCanvas.width = captureWidth;
    captureCanvas.height = captureHeight;
    captureCanvasContext.fillStyle=BackgroundColor.value
    captureCanvasContext.fillRect(0,0,captureWidth,captureHeight);

    let width=captureWidth;
    let height=captureHeight;
    let captureScaleType=aspectSelect.value;
    
    if (captureScaleType=="center")
    {
        width=mainCanvas.width
        height=mainCanvas.height
    }
    else if (captureScaleType=="fill")
    {
        if (mainCanvas.width/mainCanvas.height > width/height)
            width=height*mainCanvas.width/mainCanvas.height;
        else
            height=width*mainCanvas.height/mainCanvas.width;

    }
    else if (captureScaleType=="fit")
    {
        if (mainCanvas.width/mainCanvas.height > width/height)
            height=width*mainCanvas.height/mainCanvas.width;
        else
            width=height*mainCanvas.width/mainCanvas.height;
    }

    captureCanvasContext.drawImage(mainCanvas,captureWidth/2-width/2,captureHeight/2-height/2,width,height);
}

function ResetShader()
{
    shaderErrorText = 0;
    shaderProgram = 0;
    shaderTexture = 0;
}

function SetShaderTexture(theImage)
{
    let x = mainCanvasContext;
    x.bindTexture(x.TEXTURE_2D, shaderTexture);
    
    // fix texture being flipepd vertically
    x.pixelStorei(x.UNPACK_FLIP_Y_WEBGL, true); 

    if (theImage)
    {
        x.texImage2D(x.TEXTURE_2D, 0, x.RGBA, x.RGBA, x.UNSIGNED_BYTE, theImage);
        x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.LINEAR);
    }
    else
    {
        const pixel = new Uint8Array([255, 255, 255, 255]);
        x.texImage2D(x.TEXTURE_2D, 0, x.RGBA, 1, 1, 0, x.RGBA, x.UNSIGNED_BYTE, pixel);
    }
}

function SetShader(shader)
{
    // init shader program
    let x = mainCanvasContext;

    // pass through vertex shader
    const vertexShader = x.createShader(x.VERTEX_SHADER);
    x.shaderSource(vertexShader,"#version 300 es\n"+"in vec4 a_position;void main(){gl_Position = a_position;}");
    x.compileShader(vertexShader);

    const pixelShader = x.createShader(x.FRAGMENT_SHADER);
    x.shaderSource(pixelShader,
    "#version 300 es\n"+
    "#define HW_PERFORMANCE 0\n"+
    "precision mediump float;"+
    "uniform vec3 iResolution;"+
    "uniform float iTime;"+
    "uniform float iTimeDelta;"+
    "uniform int iFrame;"+
    "uniform int iFrameRate;"+
    "uniform vec4 iMouse;"+
    "uniform sampler2D iChannel0;"+
    "out vec4 outColor;\n"+
    shader+
    "\nvoid main(){mainImage(outColor,gl_FragCoord.xy);outColor.a=1.;}"
    //"\nvoid main(){outColor=vec4(1.,0.,0.,1.);}"//test red
    );
    x.compileShader(pixelShader);
    
    shaderProgram = x.createProgram();
    x.attachShader(shaderProgram,vertexShader);
    x.attachShader(shaderProgram, pixelShader);
    x.linkProgram(shaderProgram);
    x.getProgramParameter(shaderProgram, x.LINK_STATUS);
    /*if (!linkGood)
    {
        // something went wrong with the link
        shaderErrorText = "LINK ERROR!\n" + x.getProgramInfoLog(shaderProgram);
        return;
    }*/
    x.useProgram(shaderProgram);
    shaderTexture = x.createTexture();

    // create vertex buffer that is just 1 giant triangle with corner at 1,1
    const vertexBuffer = x.ARRAY_BUFFER;
    x.bindBuffer(vertexBuffer,x.createBuffer());
    x.bufferData(vertexBuffer,new Int8Array([-3,1,1,-3,1,1]),x.STATIC_DRAW);
    x.enableVertexAttribArray(0);
    x.vertexAttribPointer(0,2,x.BYTE,0,0,0); // 2D vertex
    
    let debugOutput="";
    let compiled = x.getShaderParameter(pixelShader, x.COMPILE_STATUS);
    let shaderLog = x.getShaderInfoLog(pixelShader);
    shaderErrorText = compiled? "" : "SHADER ERROR!\n"+shaderLog;
    let shaderErrorLine = -1;
    if (!compiled)
    {
        shaderProgram = 0;
        
        // get error line number
        let splitLog = shaderLog.split(":");
        if (splitLog.length >= 3)
        {
            shaderErrorLine = parseInt(splitLog[2]);

            //codeLineTextArea.scrollTop=errorLineNumber;
            //let lineHeight = codeTextArea.clientHeight / codeTextArea.rows;
            //let scrollTop = (errorLineNumber - 1) * lineHeight;
            //codeTextArea.scrollTop=scrollTop;
            //codeLineTextArea.scrollTop=scrollTop;
            //codeTextArea.selectionStart=0
            //codeTextArea.selectionEnd=0
        }
    }
    SetShaderTexture(image? image : mainCanvas);
}

function UpdateShader()
{
    if (!shaderProgram)
        return;

    let x = mainCanvasContext;
    x.uniform3f(x.getUniformLocation(shaderProgram,"iResolution"),mainCanvas.width,mainCanvas.height,1);
    x.uniform1f(x.getUniformLocation(shaderProgram,"iTime"),time);
    x.uniform1f(x.getUniformLocation(shaderProgram,"iTimeDelta"),1/60);
    x.uniform1f(x.getUniformLocation(shaderProgram,"iFrame"),frame);
    x.uniform1f(x.getUniformLocation(shaderProgram,"iFrameRate"),60);
    x.uniform1i(x.getUniformLocation(shaderProgram,"iChannel0"),0);
    x.uniform4f(x.getUniformLocation(shaderProgram,"iMouse"),mouseX, mouseY,mouseZ,mouseW);
    x.drawArrays(x.TRIANGLE_FAN, 0,3);
    SetShaderTexture(image? image : mainCanvas);
}

function Init()
{
    if (LoadFromURL(window.location.href))
    {
        // only load theme
        if (localStorage.settings)
        {
            let settings = JSON.parse(localStorage.settings);
            if (settings.theme)
            {
                themeSelect.value = settings.theme;
            }
        }
        if (themeSelect.selectedIndex<0)    
            themeSelect.value = "capjs"
        SelectTheme();
    }
    else
        LoadLocalStorage();
    
    // get rid of search in url
    let url = new URL(window.location.href);
    url.search="";
    window.history.pushState(null,null,url.toString())

    Reset();
    CustomInit();
}

Init();
UpdateFrameLoop();

/////////////////////////////////////////////////////////////////////// 
// uncompress dwitter code
function Uncompress(code)
{
    const i = code.toLowerCase().search(/eval\(unescape\(escape/g);
    if (i<0)
        return code;

    const codeStart = code.slice(0,i);
    const codeEnd = code.slice(i);
    try
    {
        const newCode = iframe_content.eval(codeEnd.slice(4))
        if (newCode)
            return codeStart+newCode;
    }
    catch (e) {}
    return code;
}

///////////////////////////////////////////////////////////////////////  
//download.js v4.21, by dandavis; 2008-2018. [MIT] see http://danml.com/download.html for tests/usage

(function(root,factory){typeof define=="function"&&define.amd?define([],factory):typeof exports=="object"?module.exports=factory():root.download2=factory()})(this,function(){return function download2(data,strFileName,strMimeType){let self=window,defaultMime="application/octet-stream",mimeType=strMimeType||defaultMime,payload=data,url=!strFileName&&!strMimeType&&payload,anchor=document.createElement("a"),toString=function(a){return String(a)},myBlob=self.Blob||self.MozBlob||self.WebKitBlob||toString,fileName=strFileName||"download",blob,reader;myBlob=myBlob.call?myBlob.bind(self):Blob,String(this)==="true"&&(payload=[payload,mimeType],mimeType=payload[0],payload=payload[1]);if(url&&url.length<2048){fileName=url.split("/").pop().split("?")[0],anchor.href=url;if(anchor.href.indexOf(url)!==-1){let ajax=new XMLHttpRequest;return ajax.open("GET",url,!0),ajax.responseType="blob",ajax.onload=function(e){download2(e.target.response,fileName,defaultMime)},setTimeout(function(){ajax.send()},0),ajax}}if(/^data:([\w+-]+\/[\w+.-]+)?[,;]/.test(payload)){if(!(payload.length>2096103.424&&myBlob!==toString))return navigator.msSaveBlob?navigator.msSaveBlob(dataUrlToBlob(payload),fileName):saver(payload);payload=dataUrlToBlob(payload),mimeType=payload.type||defaultMime}else if(/([\x80-\xff])/.test(payload)){let i=0,tempUiArr=new Uint8Array(payload.length),mx=tempUiArr.length;for(i;i<mx;++i)tempUiArr[i]=payload.charCodeAt(i);payload=new myBlob([tempUiArr],{type:mimeType})}blob=payload instanceof myBlob?payload:new myBlob([payload],{type:mimeType});function dataUrlToBlob(strUrl){let parts=strUrl.split(/[:;,]/),type=parts[1],indexDecoder=strUrl.indexOf("charset")>0?3:2,decoder=parts[indexDecoder]=="base64"?atob:decodeURIComponent,binData=decoder(parts.pop()),mx=binData.length,i=0,uiArr=new Uint8Array(mx);for(i;i<mx;++i)uiArr[i]=binData.charCodeAt(i);return new myBlob([uiArr],{type:type})}function saver(url,winMode){if("download"in anchor)return anchor.href=url,anchor.setAttribute("download",fileName),anchor.className="download-js-link",anchor.innerHTML="downloading...",anchor.style.display="none",anchor.addEventListener("click",function(e){e.stopPropagation()}),document.body.appendChild(anchor),setTimeout(function(){anchor.click(),document.body.removeChild(anchor),winMode===!0&&setTimeout(function(){self.URL.revokeObjectURL(anchor.href)},250)},66),!0;if(/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent))return/^data:/.test(url)&&(url="data:"+url.replace(/^data:([\w\/\-\+]+)/,defaultMime)),window.open(url)||confirm("Displaying New Document\n\nUse Save As... to download, then click back to return to this page.")&&(location.href=url),!0;let f=document.createElement("iframe");document.body.appendChild(f),!winMode&&/^data:/.test(url)&&(url="data:"+url.replace(/^data:([\w\/\-\+]+)/,defaultMime)),f.src=url,setTimeout(function(){document.body.removeChild(f)},333)}if(navigator.msSaveBlob)return navigator.msSaveBlob(blob,fileName);if(self.URL)saver(self.URL.createObjectURL(blob),!0);else{if(typeof blob=="string"||blob.constructor===toString)try{return saver("data:"+mimeType+";base64,"+self.btoa(blob))}catch(y){return saver("data:"+mimeType+","+encodeURIComponent(blob))}reader=new FileReader,reader.onload=function(e){saver(this.result)},reader.readAsDataURL(blob)}return!0}});

///////////////////////////////////////////////////////////////////////  
// Mini JS Beautifer by xem - https://github.com/xem/miniBeautifier
function BeautifyJS(e,r=0){e=e.trim(),r||(e=Uncompress(e));let c=[],n=[],l=[],t=0,a=0,s=0,p=0;for(;p!=e;){p=e;let r=e.match(/['"`\/]/);if("/"==r){let n=e.indexOf(r),s=e.slice(0,n+1);e=e[n+1].match(/[\/*]$/)?e.replace(/\/\/.*|\/\*[^]*?\*\//,function(e,r){return c.push(e),"@@c"+t++}):!s.match(/([\d\)\]\}]|true|false|null|undefined|this|@@s\d+)\s*(@@c\d+)*\s*\//m)&&s.match(/([-,;=><+%*&|^~!?!:\[\({]|delete|void|in|case|else|return|@@d|^)\s*(@@c\d+)*\s*\//m)?e.replace(/\/(\\\\|\\\/|[^\/])+?\/\w*/,function(e,r){return l.push(e),"@@r"+a++}):e.replace(/\//,"@@d")}else e="'"==r?e.replace(/'(\\\\|\\'|[^'])*?'/,function(e,r){return n.push(e),"@@s"+s++}):'"'==r?e.replace(/"(\\\\|\\"|[^"])*?"/,function(e,r){return n.push(e),"@@s"+s++}):e.replace(/`(\\\\|\\`|[^`])*?`/,function(e,r){return n.push(e),"@@s"+s++})}if(e=(e=(e=(e=(e=(e=e.replace(/@@d/g,"/")).replace(/ *(&&|\|\||!=|=>|=+|\+=|-=|\*=|\/=|\|=|\^=|%=|&=|\*\*=|!=|<=|>=|<<=|>>=|>>>=|<<|>>|[:?><=|&]) */g,r?"$1":" $1 ")).replace(/ *(\[\() */g,r?"$1":"$1 ")).replace(/ *(\]\)) */g,r?"$1":" $1")).replace(/ *(for|if|while|do|with)\s*\(+/g,r?"$1(":"\n$1 (")).replace(/ *, */g,r?",":", "),r)e=(e=(e=e.replace(/\s*(,|;)\s*/g,"$1")).replace(/ *(\()\s*/g,"$1")).replace(/\s*(\)) */g,"$1");else{let r="",c=0;for(let n=0;n<e.length;++n){let l=e[n];r+=l,"("==l?c++:")"==l?c--:","!=l&&";"!=l||(r+=c?" ":"\n")}e=(e=(e=(e=r).replace(/}/g,"\n}")).replace(/( *[{]|(case|default).*?:) */g,"$1\n")).replace(/( *[{]) */g,"\n$1\n")}return e=(e=(e=e.replace(/[\r\n]+ */g,"\n")).replace(/ +/g," ")).replace(/\n( *\n|\n)/g,"\n"),(e=(e=(e=(e=(e=r?e.replace(/@@c(\d+)/g,""):e.replace(/@@c(\d+)/g,function(e,r){return c[r]})).replace(/\s*@@s(\d+)\s*/g,function(e,c){return r?n[c]:" "+n[c]+" "})).replace(/\s*@@r(\d+)\s*/g,function(e,c){return r?l[c]:" "+l[c]+" "})).replace(/\n+/g,"\n")).replace(/;*\s*$/g,"")).trim()}

///////////////////////////////////////////////////////////////////////  
// JS Crush

function JSCrush(e){let t=[];for(let e=32;e<256;++e){let l=String.fromCharCode(e);"`"!=l&&"\\"!=l&&t.push(l)}const l=((e,t)=>{let l=t.length,n="";const r=e=>e.length,o=e=>{let t=e.charCodeAt(0),l=e.charCodeAt(e.length-1);return t>=56320&&t<=57343||l>=55296&&l<=56319};let i={};for(let t=2;t<50;t++)for(let l=0;l<e.length-t;++l){let n=e.substr(l,t);if(i[n])continue;if(o(n))continue;let r=1;for(let o=e.indexOf(n,l+t);o>=0;++r)o=e.indexOf(n,o+t);r>1&&(i[n]=r)}for(;;){for(;l--&&e.includes(t[l]););if(l<0)break;let o,f=t[l],h=0,s=r(f);for(let e in i){let t=i[e],l=(t-1)*r(e)-(t+1)*s;l<=0?delete i[e]:l>h&&(o=e,h=l)}if(!o)break;e=e.split(o).join(f)+f+o,n=f+n;let u={};for(let t in i){let l=t.split(o).join(f),n=0;for(let t=e.indexOf(l);t>=0;++n)t=e.indexOf(l,t+l.length);n>1&&(u[l]=n)}i=u}return{a:e,b:n}})(e=e.replace(/`/g,"\\`"),t);return"$=`"+l.a+"`;for(_ of `"+l.b+"`)with($.split(_))$=join(pop());eval($)"}

/////////////////////////////////////////////////////////////////////// 
// JSONCrush by Frank Force [MIT] https://github.com/KilledByAPixel/JSONCrush
function JSONCrush(e){let t=[];const n="-_.!~*'()";for(let e=127;--e;)(e>=48&&e<=57||e>=65&&e<=90||e>=97&&e<=122||n.includes(String.fromCharCode(e)))&&t.push(String.fromCharCode(e));for(let e=32;e<255;++e){let n=String.fromCharCode(e);"\\"==n||t.includes(n)||t.unshift(n)}const l=((e,t)=>{let n=t.length,l="";const r=e=>encodeURI(encodeURIComponent(e)).replace(/%../g,"i").length,o=e=>{let t=e.charCodeAt(0),n=e.charCodeAt(e.length-1);return t>=56320&&t<=57343||n>=55296&&n<=56319};let i={};for(let t=2;t<50;t++)for(let n=0;n<e.length-t;++n){let l=e.substr(n,t);if(i[l])continue;if(o(l))continue;let r=1;for(let o=e.indexOf(l,n+t);o>=0;++r)o=e.indexOf(l,o+t);r>1&&(i[l]=r)}for(;;){for(;n--&&e.includes(t[n]););if(n<0)break;let o,f=t[n],s=0,c=r(f);for(let e in i){let t=i[e],n=(t-1)*r(e)-(t+1)*c;l.length||(n-=r("")),n<=0?delete i[e]:n>s&&(o=e,s=n)}if(!o)break;e=e.split(o).join(f)+f+o,l=f+l;let u={};for(let t in i){let n=t.split(o).join(f),l=0;for(let t=e.indexOf(n);t>=0;++l)t=e.indexOf(n,t+n.length);l>1&&(u[n]=l)}i=u}return{a:e,b:l}})(e=JSONCrushSwap(e=e.replace(new RegExp("","g"),"")),t);let r=l.a;return l.b.length&&(r+=""+l.b),encodeURIComponent(r+"_")}function JSONUncrush(e){e=e.substring(0, e.length-1);const t=e.split("");let n=t[0];if(t.length>1){let e=t[1];for(let t of e){let e=n.split(t);n=e.join(e.pop())}}return JSONCrushSwap(n,0)}function JSONCrushSwap(e,t=1){const n=[['"',"'"],["':","!"],[",'","~"],["}",")","\\","\\"],["{","(","\\","\\"]],l=(e,t)=>{let n=new RegExp(`${(t[2]?t[2]:"")+t[0]}|${(t[3]?t[3]:"")+t[1]}`,"g");return e.replace(n,e=>e===t[0]?t[1]:t[0])};if(t)for(let t=0;t<n.length;++t)e=l(e,n[t]);else for(let t=n.length;t--;)e=l(e,n[t]);return e}

</script>
</body>
</html>

<!-- CCapture.js License

The MIT License

Copyright (c) 2012 Jaume Sanchez Elias

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

-->
<!-- three.js License

The MIT License

Copyright ¬© 2010-2019 three.js authors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

-->
<!-- Code Mirror License

MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

-->